{"name": "Lean Game Template", "version": "0.1", "languages": ["en"], "translated_name": "0", "devmode": false, "library_zip_fn": "Lean Game Template-0.1-library.zip", "introData": {"name": "", "problemIndex": -1, "objects": [{"type": "text", "content": "1"}]}, "worlds": [{"name": "2", "levels": [{"name": "", "problemIndex": 11, "objects": [{"type": "lean", "content": "3", "hidden": true}, {"type": "text", "content": "4"}, {"type": "lean", "content": "5", "hidden": false}, {"type": "text", "content": "6"}, {"type": "lean", "content": "7", "hidden": false}, {"type": "text", "content": "8"}, {"type": "lean", "content": "9", "hidden": false}, {"type": "text", "content": "10"}, {"type": "tactic", "content": "11", "name": "cases", "sideBar": true}, {"type": "lean", "content": "12", "hidden": true}, {"type": "text", "content": "13"}, {"type": "theorem", "text": "14", "lean": "theorem decomposing_and (a b c : Prop) (h: a \u2227 ((b \u2227 a) \u2227 c)) : b :=\n", "sideBar": false, "firstProofLineNumber": 118, "lastProofLineNumber": 125, "textBefore": "import data.int.basic tactic.pure_maths -- hide\n\n/-\n# Propositional logic\n## Level 1: And elimination\n\nWelcome to propositional logic in LEAN! In this first level, we will introduce the \nconcept of and elimination.\n\nSay we have the hypothesis \u2018h: cats AND dogs\u2019, we can logically conclude that we have \n\u2018cats\u2019, and that we have \u2018dogs\u2019. But how do we actually prove these two facts? By \nusing and elimination!\n-/\n\nexample (dogs cats : Prop) (h: dogs \u2227 cats) : cats :=\nbegin\n  from h.right,\nend\n\nexample (dogs cats : Prop) (h: dogs \u2227 cats) : dogs :=\nbegin\n  from h.left,\nend\n\n/- \n\nThese are the proofs in LEAN, but what do they actually mean? h is our hypothesis \n(or premise), which is a fancy way of saying that h is what we know. The symbol \u2227 is\ncalled a conjugation (it just means \u2018and\u2019) and can be typed in LEAN using \\and. \n\nIn the first example, \u2018cats\u2019 is our goal, and we reach this goal by using \u2018from h.right\u2019,\nwhich is an abbreviation for \u2018from and_elim_right h\u2019. Informally, this is the same as \nsaying \u2018we have cats from right and elimination on h\u2019.\n\nAnd the second example is the same, but we instead use \u2018from h.left\u2019 (short for \n\u2018from and.elim_left h\u2019) to reach our goal of \u2018dogs\u2019. Informally, this is \u2018we have dogs \nfrom left and elimination on h\u2019.\n\nThis example was rather a simple one, now let\u2019s look at one with more than one conjugation.\n-/\n\nexample (red blue yellow : Prop) (h: red \u2227 (blue \u2227 yellow)) : yellow :=\nbegin\n  have g: blue \u2227 yellow, from h.right,\n  from g.right,\nend\n\n/-\n\nIn this example, our hypothesis is \u2018h: red and (blue and yellow)\u2019 and our goal is to \nshow that we have yellow. The first step to achieving this is \u2018have g: blue \u2227 yellow, from \nh.right\u2019. This creates a new hypothesis g, and is equivalent to saying \u2018we have \u201cg: blue and \nyellow\u201d from right and elimination on h\u2019. We complete the proof in exactly the same way as \nin the first example, except this time we use \u2018from g.right\u2019, or informally, \u2018we have yellow\nfrom right and elimination on g\u2019.\n\nAnother way we can create a new hypothesis from our original one is to use the tactic \n\u2018cases\u2019. This tactic will automatically decompose a hypothesis with a conjugation into \nit\u2019s left and right hand sides. Here\u2019s the last example, but this time using the \ntactic \u2018cases\u2019.\n\n-/\n\nexample (red blue yellow : Prop) (h: red \u2227 (blue \u2227 yellow)) : yellow :=\nbegin\n  cases h with f g,\n  from g.right,\nend\n\n/-\n\nAs you can see, we instead started our proof with \u2018cases h with f g\u2019, which creates the two \nnew premises, \u2018f: red\u2019 and \u2018g: blue \u2227 yellow\u2019, and the rest of the proof follows as before.\n\n-/\n\n\n/- Tactic : cases\n`cases` is a general-purpose elimination tactic. It it used to 'decompose' a hypothesis into\nits constituent parts.\n\n### Examples\n\n* Given `h : \u2203 (x : \u2124), x + 5 = y`, typing `cases h with m h\u2082` replaces `h` with `m : \u2124` and\n`h\u2082 : m + 5 = y`.\n\n* Given `h : p \u2227 q`, typing `cases h with hp hq` replaces `h` with `hp : p` and `hq : q`.\n\n* Given `h : p \u2228 q`, typing `cases h with hp hq` replaces the current goal with two goals\n(1) in which `h` is replaced with `hp : p` and (2) in which `h` is replaced with `hq : q`.\n\n* Given `x : \u2115`, typing `cases x with k` replaces the goal with two new goals: (1) a goal in which\nevery occurence of `x` is replaced with `0` and (2) a goal with a new variable `k : \u2115` and in \nwhich every occurrence of `x` is replaced with `succ k`.\n\n* Given `h : \u2203 (x : X), P(x)`, typing `cases h with y h\u2082` introduces a new variable `y : X`\nand replaces `h` with `h\u2082 : P(y)`.\n-/\n\n\nnamespace exlean -- hide\n\n/-\n\nNow it\u2019s your turn to have a go! Below, you will find a problem that can be solved using a \ncombination of left and elimination and right and elimination (and the tactic \u2018cases\u2019 if you \nso desire\u2019). Remember to end each line with a comma, and you\u2019ll know your proof is correct if \nthe right hand side box says \u2018Proof complete!\u2019.\n\n-/\n\n/- Theorem : no-side-bar\nLet $a$, $b$, $c$ be propositions. Assuming $h: a \\land ((b \\land a) \\land c)$, we have $b$.\n-/\n\ntheorem decomposing_and (a b c : Prop) (h: a \u2227 ((b \u2227 a) \u2227 c)) : b :=\nbegin\n", "proof": "  have g: (b \u2227 a) \u2227 c, from and.elim_right h,\n  have f: b \u2227 a, from and.elim_left g,\n  from and.elim_left f,\n  \n  \n  \n  \n  ", "proof_hint": "sorry", "textAfter": "\nend\n\n\nend exlean -- hide\n", "height": 8, "editorText": "sorry", "lineOffset": 117, "name": "decomposing_and", "statement": "(a b c : Prop) (h: a \u2227 ((b \u2227 a) \u2227 c)) : b"}, {"type": "lean", "content": "15", "hidden": true}]}, {"name": "", "problemIndex": 8, "objects": [{"type": "lean", "content": "16", "hidden": true}, {"type": "text", "content": "17"}, {"type": "lean", "content": "18", "hidden": false}, {"type": "text", "content": "19"}, {"type": "lean", "content": "20", "hidden": false}, {"type": "text", "content": "21"}, {"type": "lean", "content": "22", "hidden": true}, {"type": "text", "content": "23"}, {"type": "theorem", "text": "24", "lean": "theorem and_intro_thm (a b c : Prop) (h: a) (g: b) (f: c) : c \u2227 a :=\n", "sideBar": false, "firstProofLineNumber": 66, "lastProofLineNumber": 71, "textBefore": "import tactic.pure_maths -- hide\n\n/-\n# Propositional logic\n## Level 2: And introduction\n\nNow that you\u2019ve seen how to prove a proposition from a conjugation, it\u2019s time to prove a \nconjugation from a proposition! \n\nLet\u2019s take our initial example of dogs and cats from level 1 but instead go the other way.\n\n-/\n\nexample (dogs cats : Prop) (h: dogs) (g: cats) : dogs \u2227 cats :=\nbegin \n  from and.intro h g,\nend\n\n/-\n\nThis time, we started with two hypotheses, \u2018h: dogs\u2019 and \u2018g: cats\u2019, and our goal was to \nprove \u2018dogs and cats\u2019. We did this using and introduction, which is the propositional logic \nway of saying \u2018if we have dogs, and we have cats, then we have dogs and cats\u2019.\n\nAnother way in which we can prove a conjugation is to break it down into two separate \ngoals. This is done by using the \u2018split\u2019 tactic.\n\n-/\n\nexample (dogs cats : Prop) (h: dogs) (g: cats) : dogs \u2227 cats :=\nbegin \n  split,\n  {show dogs, from h, },\n  {show cats, from g, },\nend\n\n/-\n\nAs you can see, the \u2018split\u2019 tactic changed our single goal of \u2018dogs and cats\u2019 into \ntwo separate goals, one being \u2018dogs\u2019 and the other being \u2018cats\u2019. This is an example\nof a backwards proof, and is in some cases easier than trying to construct a proof \nin the forwards direction. \n\nYou may have noticed that after using the split tactic, we introduced some curly \nbrackets. This is because we now have two goals, so the brackets tell LEAN which \nlines of our proof relate to each goal.\n\n-/\n\n\n\nnamespace exlean -- hide\n/-\n\nHave a go at constructing the following proof. You may use either \u2018and.intro\u2019 or the \nsplit tactic to do so.\n\n-/\n\n/- Theorem: no-side-bar\nLet $a$, $b$, $c$ be propositions. Assuming $h: a$, $g: b$, and $f: c$, we have $c \\land a$.\n-/\n\ntheorem and_intro_thm (a b c : Prop) (h: a) (g: b) (f: c) : c \u2227 a :=\nbegin\n", "proof": "  split,\n  {show c, from f, },\n  {show a, from h, },\n\n\n", "proof_hint": "sorry", "textAfter": "\nend\n\nend exlean -- hide\n", "height": 6, "editorText": "sorry", "lineOffset": 65, "name": "and_intro_thm", "statement": "(a b c : Prop) (h: a) (g: b) (f: c) : c \u2227 a"}, {"type": "lean", "content": "25", "hidden": true}]}, {"name": "", "problemIndex": 3, "objects": [{"type": "lean", "content": "26", "hidden": true}, {"type": "text", "content": "27"}, {"type": "lean", "content": "28", "hidden": true}, {"type": "theorem", "text": "29", "lean": "theorem and_swap (a b : Prop) (h: a \u2227 b) : b \u2227 a :=\n", "sideBar": true, "firstProofLineNumber": 22, "lastProofLineNumber": 28, "textBefore": "import tactic.pure_maths -- hide\n\n/-\n# Propositional logic\n## Level 3: And swap\n\nIn this level, we will be proving that you can get $b \\land a$ from $a \\land b$. \nIntuitively, I\u2019m sure this fact is obvious but before we can just use it in future \nproofs, we need to prove it's true. After this level, you'll be able to use 'and.swap' \nto swap the propositions in a conjugation. Levels 1 and 2 have given us all the tools \nwe need to do this, so I leave the rest up to you!\n\n-/\n\nnamespace exlean -- hide\n\n/- Theorem :\nLet $a$ and $b$ be propositions. Assuming $h: a \\land b$, we have $g: b \\land a$.\n-/\ntheorem and_swap (a b : Prop) (h: a \u2227 b) : b \u2227 a :=\nbegin\n", "proof": "  split,\n  {from h.right, },\n  {from h.left, },\n\n\n\n", "proof_hint": "sorry", "textAfter": "\nend\n\nend exlean -- hide\n", "height": 7, "editorText": "sorry", "lineOffset": 21, "name": "and_swap", "statement": "(a b : Prop) (h: a \u2227 b) : b \u2227 a"}, {"type": "lean", "content": "30", "hidden": true}]}, {"name": "", "problemIndex": 5, "objects": [{"type": "lean", "content": "31", "hidden": true}, {"type": "text", "content": "32"}, {"type": "lean", "content": "33", "hidden": false}, {"type": "text", "content": "34"}, {"type": "lean", "content": "35", "hidden": true}, {"type": "theorem", "text": "36", "lean": "theorem imp_elim_example (a b c d : Prop) (h : a \u2192 b) (g : c \u2227 d) (f : d \u2192 a) : b :=\n", "sideBar": false, "firstProofLineNumber": 38, "lastProofLineNumber": 45, "textBefore": "import propositional_logic.and_swap -- hide\n\n/-\n# Propositional logic\n## Level 4: Implication elimination\n\nNow we will start to consider implications, starting with implication elimination. \nIf we are given the hypotheses $h: a \\r b$ and $g : a$ then we have a proof of a.\n\n-/\n\nexample (a b : Prop) (h : a \u2192 b) (g : a) : b :=\nbegin\n  from h g,\nend \n\n/- \n\nAs you can see, this example isn\u2019t exactly complicated but we can combine our \nimplication elimination with what we\u2019ve seen in previous levels to construct more \ncomplex proofs. Have a go at the one below, using the theorems and tactics we\u2019ve \ncovered so far.\n\n(Note that the implication arrow can be written in LEAN using \u2018\\r\u2019)\n\n-/\n\nnamespace exlean -- hide\n\n\n\n/- Theorem : no-side-bar\nLet $a$, $b$, $c$, and $d$ be propositions. Assuming $h : a \\to b$, $g : c \\land d$,\nand $f : d \\to a$, we have $b$.\n-/\ntheorem imp_elim_example (a b c d : Prop) (h : a \u2192 b) (g : c \u2227 d) (f : d \u2192 a) : b :=\nbegin\n", "proof": "  have h\u2081 : d, from and.elim_right g,\n  have h\u2082 : a, from f h\u2081,\n  show b, from h h\u2082 ,\n  \n\n\n\n", "proof_hint": "sorry", "textAfter": "\nend \n\nend exlean -- hide\n", "height": 8, "editorText": "sorry", "lineOffset": 37, "name": "imp_elim_example", "statement": "(a b c d : Prop) (h : a \u2192 b) (g : c \u2227 d) (f : d \u2192 a) : b"}, {"type": "lean", "content": "37", "hidden": true}]}, {"name": "", "problemIndex": 7, "objects": [{"type": "lean", "content": "38", "hidden": true}, {"type": "text", "content": "39"}, {"type": "lean", "content": "40", "hidden": false}, {"type": "text", "content": "41"}, {"type": "lean", "content": "42", "hidden": false}, {"type": "lean", "content": "43", "hidden": true}, {"type": "text", "content": "44"}, {"type": "theorem", "text": "45", "lean": "theorem imp_intro_example (a b c : Prop) (h : b \u2192 c) : (a \u2227 b) \u2192 c :=\n", "sideBar": false, "firstProofLineNumber": 51, "lastProofLineNumber": 57, "textBefore": "import propositional_logic.imp_elim -- hide\n\n/-\n# Propositional logic\n## Level 5: Implication introduction\n\nContinuing on our implication journey, in this level we will be looking at implication \nintroduction. It\u2019s worth prefacing this level by saying that the first couple of examples \nmay seem so obvious as to be trivial, so take a moment to consider why they are important\nstatements to prove.\n\n-/\n\nvariable (a : Prop)\nexample : a \u2192 a  :=\nbegin\n  assume h : a,\n  show a, from h,\nend\n\n/-\n\nThis lemma is very simple but is important to have in our arsenal. In order to prove it, \nwe assumed a hypothesis to be true, that being $h : a$, and then proved that having $a$ \nimplies that we have $a$. Much like with implication elimination, we can combine it with\nour previous theorems to construct longer proofs.\n\n-/\n\nexample (a b : Prop) : (a \u2227 b) \u2192 b :=\nbegin\n  assume h : a \u2227 b,\n  from and.elim_right h,\nend\n\nnamespace exlean -- hide\n\n/-\n\nHave a go at the example below and in the next level we\u2019ll meet a slightly more involved \nproof.\n\n-/\n\n/- Theorem: no-side-bar\nLet $a$, $b$, and $c$ be propositions and assume $h : b \\to c$. Then $(a \\land b) \\to c$.\n-/\n\ntheorem imp_intro_example (a b c : Prop) (h : b \u2192 c) : (a \u2227 b) \u2192 c :=\nbegin\n", "proof": "  assume g : a \u2227 b,\n  have f : b, from and.elim_right g,\n  show c, from h f,\n  \n  \n  \n  ", "proof_hint": "sorry", "textAfter": "\nend\n\nend exlean -- hide\n", "height": 7, "editorText": "sorry", "lineOffset": 50, "name": "imp_intro_example", "statement": "(a b c : Prop) (h : b \u2192 c) : (a \u2227 b) \u2192 c"}, {"type": "lean", "content": "46", "hidden": true}]}, {"name": "", "problemIndex": 3, "objects": [{"type": "lean", "content": "47", "hidden": true}, {"type": "text", "content": "48"}, {"type": "lean", "content": "49", "hidden": true}, {"type": "theorem", "text": "50", "lean": "theorem and_imp_combo (a b c d : Prop) (h\u2081 : a \u2192 b) (h\u2082 : a \u2227 c) (h\u2083 : (c \u2227 a) \u2192 d) : d \u2227 b :=\n", "sideBar": false, "firstProofLineNumber": 20, "lastProofLineNumber": 27, "textBefore": "import propositional_logic.imp_elim -- hide\n\n/-\n#Propositional logic\n## Level 6: Conjugation and Implication\n\nin this level there will be no examples, instead there is just a single, \nlonger exercise for you to have a go at before we move on to the next level.\n\n-/\n\nnamespace exlean -- hide\n\n/- Theorem : no-side-bar\nLet $a$, $b$, $c$, and $d$ be propositions. Assuming $h_1 : a \\to b$, $h_2 : a \\land c$,\nand $h_3 : (c \\land a) \\to d$, we have $d \\land b$.\n-/\ntheorem and_imp_combo (a b c d : Prop) (h\u2081 : a \u2192 b) (h\u2082 : a \u2227 c) (h\u2083 : (c \u2227 a) \u2192 d) : d \u2227 b :=\nbegin\n", "proof": "  have h : c \u2227 a, from and.swap h\u2082,\n  have g : d, from h\u2083 h,\n  have f : a, from and.elim_left h\u2082,\n  have e : b, from h\u2081 f,\n  from and.intro g e,\n  \n  \n  ", "proof_hint": "sorry", "textAfter": "\nend\n\nend exlean -- hide\n", "height": 8, "editorText": "sorry", "lineOffset": 19, "name": "and_imp_combo", "statement": "(a b c d : Prop) (h\u2081 : a \u2192 b) (h\u2082 : a \u2227 c) (h\u2083 : (c \u2227 a) \u2192 d) : d \u2227 b"}, {"type": "lean", "content": "51", "hidden": true}]}, {"name": "", "problemIndex": 5, "objects": [{"type": "lean", "content": "52", "hidden": true}, {"type": "text", "content": "53"}, {"type": "lean", "content": "54", "hidden": false}, {"type": "text", "content": "55"}, {"type": "lean", "content": "56", "hidden": true}, {"type": "theorem", "text": "57", "lean": "theorem or_intro_example (a b c d : Prop) (h\u2081 : a) (h\u2082 : b) (h\u2083 : c) : d \u2228 (a \u2227 (b \u2227 c)):=\n", "sideBar": false, "firstProofLineNumber": 42, "lastProofLineNumber": 47, "textBefore": "import propositional_logic.imp_elim -- hide\n\n/-\n#Propositional logic\n## Level 7: Or introduction\n\nNow it is time to introduce disjunction, which is represented by the symbol \n$ \\lor $, which can be typed in LEAN as \u2018\\or\u2019. Let\u2019s look to an example to \nsee how it works.\n\n-/\n\nexample (a b : Prop) (h : a) : a \u2228 b :=\nbegin\n  from or.inl h,\nend\n\n/-\n\nIn the above example, our hypothesis is $h : a$ and our goal is to show $a \\lor b$. \nThis is done using or introduction on $h$. Informally, we can look at this as \u2018if we \nhave $a$, then we have $a$ or $b$\u2019.\n\nIt\u2019s important to note that in a true disjunction statement such as \u2018$p \\lor q$\u2019 it \nis possible that both $p$ and $q$ are true but it is sufficient for only one of them \nto be true.\n\nOr introduction isn\u2019t often used in isolation, but rather it is paired with other \nrules of inference, and so the following exercise will use or introduction as well as \ntheorems from previous levels.\n\n-/\n\nnamespace exlean -- hide\n\n/- Theorem : no-side-bar\nLet $a$, $b$, $c$, and $d$ be propositions, and assume $h_1 : a$, $h_2 : b$, and $h_3. \nThen we have $d \\lor (a \\land (b \\land c)).\n-/\ntheorem or_intro_example (a b c d : Prop) (h\u2081 : a) (h\u2082 : b) (h\u2083 : c) : d \u2228 (a \u2227 (b \u2227 c)):=\nbegin\n", "proof": "  have h: b \u2227 c, from and.intro h\u2082 h\u2083 ,\n  have g : a \u2227 (b \u2227 c), from and.intro h\u2081 h,\n  from or.inr g,\n  \n  \n  ", "proof_hint": "sorry", "textAfter": "\nend\n\nend exlean -- hide\n\n", "height": 6, "editorText": "sorry", "lineOffset": 41, "name": "or_intro_example", "statement": "(a b c d : Prop) (h\u2081 : a) (h\u2082 : b) (h\u2083 : c) : d \u2228 (a \u2227 (b \u2227 c))"}, {"type": "lean", "content": "58", "hidden": true}]}, {"name": "", "problemIndex": 5, "objects": [{"type": "lean", "content": "59", "hidden": true}, {"type": "text", "content": "60"}, {"type": "lean", "content": "61", "hidden": false}, {"type": "text", "content": "62"}, {"type": "lean", "content": "63", "hidden": true}, {"type": "theorem", "text": "64", "lean": "theorem or_elim_example (a b c d : Prop) (h\u2081 : a \u2228 d) (h\u2082 : a \u2192 c) \n(h\u2083 : a \u2192 b) (h\u2084 : d \u2192 b) (h\u2085 : d \u2192 c) : b \u2227 c :=\n", "sideBar": false, "firstProofLineNumber": 40, "lastProofLineNumber": 45, "textBefore": "import propositional_logic.and_swap -- hide\n\n/-\n# Propositional logic\n## Level 8: Or elimination\n\nNow we will introduce or elimination. Informally, this works by showing that\nboth sides of a disjunction lead to our goal.\n\n-/\n\nexample (a b c : Prop) (h\u2081 : a \u2228 b) (h\u2082 : a \u2192 c) (h\u2083 : b \u2192 c) : c :=\nbegin\n  from or.elim h\u2081 h\u2082 h\u2083,\nend\n\n/-\n\nAlthough the above proof is only a single line, we\u2019re actually doing a fair bit. \nOr elimination breaks up the disjunction into two separate assumptions; in this \ncase the assumption of $a$ and then the assumption of $b$. We then prove that each\nof these individual assumptions implies our goal and, as we know at least one of \nthe assumptions is true, we can conclude that we have reached our goal.\n\nOr introduction is often used alongside negation, which we\u2019ll get to in the next \nlevel, but for now have a go at the exercise below.\n\n-/\n\nnamespace exlean -- hide\n\n/- Theorem : no-side-bar\nLet $a$, $b$, $c$, and $d$ be propositons. Assuming $h_1 : a \\lor b$, $h_2 : a \\to c$,\n$h_3 : a \\to b$, $h_4 : d \\to b$, and $h_5 : d \\to c$, we have $b \\land c$.\n-/\n\ntheorem or_elim_example (a b c d : Prop) (h\u2081 : a \u2228 d) (h\u2082 : a \u2192 c) \n(h\u2083 : a \u2192 b) (h\u2084 : d \u2192 b) (h\u2085 : d \u2192 c) : b \u2227 c :=\nbegin\n", "proof": "  split,\n  {from or.elim h\u2081 h\u2083 h\u2084,},\n  {from or.elim h\u2081 h\u2082 h\u2085,},\n  \n  \n  ", "proof_hint": "sorry", "textAfter": "\nend\n\nend exlean -- hide\n", "height": 6, "editorText": "sorry", "lineOffset": 39, "name": "or_elim_example", "statement": "(a b c d : Prop) (h\u2081 : a \u2228 d) (h\u2082 : a \u2192 c) \n(h\u2083 : a \u2192 b) (h\u2084 : d \u2192 b) (h\u2085 : d \u2192 c) : b \u2227 c"}, {"type": "lean", "content": "65", "hidden": true}]}, {"name": "", "problemIndex": 5, "objects": [{"type": "lean", "content": "66", "hidden": true}, {"type": "text", "content": "67"}, {"type": "lean", "content": "68", "hidden": false}, {"type": "text", "content": "69"}, {"type": "lean", "content": "70", "hidden": true}, {"type": "theorem", "text": "71", "lean": "theorem neg_example (a b : Prop) : (a \u2192 b) \u2192 (\u00acb \u2192 \u00aca) :=\n", "sideBar": false, "firstProofLineNumber": 44, "lastProofLineNumber": 53, "textBefore": "import propositional_logic.imp_elim -- hide\n\n/-\n#Propositional logic\n## Level 9: Negation\n\nNegation is the propositional logic way of saying \u2018not\u2019. The symbol for negation is $\\neg$ \nand is written in LEAN using \u2018\\neg\u2019. As you would expect, two negations informally\nmeans \u2018not-not\u2019, and so we can prove that \u2018$p \\to \\neg \\neg p$\u2019.\n\n-/\n\nexample (p : Prop) : p \u2192 \u00ac\u00acp :=\nbegin\n  assume h : p,\n  show \u00ac \u00ac p,\n  show \u00acp \u2192 false,\n  assume g : \u00ac p,\n  show false, from g h,\nend\n\n/-\n\nThe above proof starts how we expect an implication proof to start, by assuming $h : p$. \nOur initial goal is to show \u2018$ \\neg \\neg p$\u2019 and in order to achieve this we change our \ngoal to showing \u2018$ \\neg p \\to \\bot$\u2019 (note that $\\bot$ is written as \u2018false\u2019 in LEAN). This \nis another implication proof, so we again start with an assumption \u2018$g : \\neg p$\u2019, making \nour goal simply \u2018$\\bot$\u2019. This follows from $h$ and $g$ as we can\u2019t have both $p$ and $\\neg p$\nwithout having a contradiction.\n\nNegation can be hard to wrap your head around when written down in such a way, so it\u2019s worth \ntaking some time to really understand what\u2019s going on in the example above. It\u2019s an example \nof proof by contradiction, as is the exercise below.\n\n-/\n\nnamespace exlean -- hide\n\n/- Theorem : no-side-bar\nLet $a$, and $b$ be propositions. Then $(a \\to b) \\to (\\neg b \\to \\neg a)$.\n-/\ntheorem neg_example (a b : Prop) : (a \u2192 b) \u2192 (\u00acb \u2192 \u00aca) :=\nbegin\n", "proof": "  assume h\u2081 : a \u2192 b,\n  show \u00acb \u2192 \u00aca,\n  assume h\u2082 : \u00acb,\n  show \u00aca,\n  assume f : a,\n  have g : b, from h\u2081 f,\n  show false, from h\u2082 g,\n  \n  \n  ", "proof_hint": "sorry", "textAfter": "\nend\n\nend exlean -- hide\n", "height": 10, "editorText": "sorry", "lineOffset": 43, "name": "neg_example", "statement": "(a b : Prop) : (a \u2192 b) \u2192 (\u00acb \u2192 \u00aca)"}, {"type": "lean", "content": "72", "hidden": true}]}, {"name": "", "problemIndex": 3, "objects": [{"type": "lean", "content": "73", "hidden": true}, {"type": "text", "content": "74"}, {"type": "lean", "content": "75", "hidden": true}, {"type": "theorem", "text": "76", "lean": "lemma dis_to_neg_con (a b : Prop) : (\u00aca \u2228 \u00acb) \u2192 \u00ac(a \u2227 b) :=\n", "sideBar": false, "firstProofLineNumber": 20, "lastProofLineNumber": 31, "textBefore": "import propositional_logic.imp_elim -- hide\n\n/-\n#Propositional logic\n## Level 10: Disjunction and Negation\n\nAs mentioned in level 8, disjunction is often found alongside negation. There \nare no examples in this level, instead there is a lemma for you to prove, using \nwhat you\u2019ve learnt in the previous levels.\n\n-/\n\nnamespace exlean -- hide\n\n/- Theorem : no-side-bar\nLet $a$, and $b$ be propositions. Then $(\\neg a \\lor \\neg b) \\to \\neg (a \\land b)$.\n-/\nlemma dis_to_neg_con (a b : Prop) : (\u00aca \u2228 \u00acb) \u2192 \u00ac(a \u2227 b) :=\nbegin\n", "proof": "  assume h\u2081 : \u00aca \u2228 \u00acb,\n  show \u00ac(a \u2227 b),\n  cases h\u2081 with h\u2082 h\u2083,\n  {assume g\u2081 : a \u2227 b,\n  have g\u2082 : a, from and.elim_left g\u2081,\n  show false, from h\u2082 g\u2082,},\n  {assume f\u2081 : a \u2227 b,\n  have f\u2082 : b, from and.elim_right f\u2081,\n  show false, from h\u2083 f\u2082,},\n  \n  \n  ", "proof_hint": "sorry", "textAfter": "\nend\n\nend exlean -- hide\n", "height": 12, "editorText": "sorry", "lineOffset": 19, "name": "dis_to_neg_con", "statement": "(a b : Prop) : (\u00aca \u2228 \u00acb) \u2192 \u00ac(a \u2227 b)"}, {"type": "lean", "content": "77", "hidden": true}]}, {"name": "", "problemIndex": 5, "objects": [{"type": "lean", "content": "78", "hidden": true}, {"type": "text", "content": "79"}, {"type": "lean", "content": "80", "hidden": false}, {"type": "text", "content": "81"}, {"type": "lean", "content": "82", "hidden": true}, {"type": "theorem", "text": "83", "lean": "theorem iff_elim (a b c : Prop) (h : a \u2194 (b \u2227 c)) : a \u2192 c :=\n", "sideBar": false, "firstProofLineNumber": 38, "lastProofLineNumber": 44, "textBefore": "import propositional_logic.imp_elim -- hide\n\n/-\n#Propositional logic\n## Level 11: Iff elimination\n\n\u2018Iff\u2019 (shorthand for \u2018if and only if\u2019, written in LEAN as \u2018\\iff\u2019) is an implication \nthat goes both ways.\n\n-/\n\nexample (a b : Prop) (h : a \u2194 b) : a \u2192 b :=\nbegin\n  from iff.elim_left h,\nend\n\nexample (a b : Prop) (h : a \u2194 b) : b \u2192 a :=\nbegin\n  from iff.elim_right h,\nend\n\n/-\n\nBy using left iff elimination, we are able to prove from $a \\iff b$ that $a \\to b$, \nand similiarly using right iff elimination, we can prove $b \\to a$. There\u2019s not much\nmore to iff elimination, so have a go at the exercise and then move on to the finally \nlevel in this world.\n\n-/\n\nnamespace exlean -- hide\n\n/- Theorem : no-side-bar\nLet $a$, $b$, and $c$ be propositions. Assuming $h : a \\iff (b \\land c)$, then $a \\to c$.\n-/\ntheorem iff_elim (a b c : Prop) (h : a \u2194 (b \u2227 c)) : a \u2192 c :=\nbegin\n", "proof": "  have h\u2081 : a \u2192 b \u2227 c, from iff.elim_left h,\n  assume h\u2082 : a,\n  have h\u2083 : b \u2227 c, from h\u2081 h\u2082,\n  from and.elim_right h\u2083,\n  \n  \n  ", "proof_hint": "sorry", "textAfter": "\nend \n\n\nend exlean -- hide\n", "height": 7, "editorText": "sorry", "lineOffset": 37, "name": "iff_elim", "statement": "(a b c : Prop) (h : a \u2194 (b \u2227 c)) : a \u2192 c"}, {"type": "lean", "content": "84", "hidden": true}]}, {"name": "", "problemIndex": 5, "objects": [{"type": "lean", "content": "85", "hidden": true}, {"type": "text", "content": "86"}, {"type": "lean", "content": "87", "hidden": false}, {"type": "text", "content": "88"}, {"type": "lean", "content": "89", "hidden": true}, {"type": "theorem", "text": "90", "lean": "theorem iff_intro (a b c x y z: Prop) (h\u2081 : (b \u2227 c) \u2194 a) (h\u2082 : (y \u2227 z) \u2194 x) \n(h\u2083 : a \u2194 x) : (b \u2227 c) \u2194 (y \u2227 z) :=\n", "sideBar": false, "firstProofLineNumber": 39, "lastProofLineNumber": 54, "textBefore": "import propositional_logic.imp_elim -- hide\n\n/-\n#Propositional logic\n## Level 12: Iff introduction\n\nWelcome to the final level of propositional logic! Once you\u2019ve completed this \nlevel, there\u2019s a bonus world with some more challenging proofs to have a go at so \nplease head back to the main menu and have a go. But first, iff introduction!\n\nIff introduction, as you might expect, if the opposite of iff elimination; it takes\ntwo implication statements and creates a single iff statement.\n\n-/\n\nexample (a b : Prop) (h\u2081 : a \u2192 b) (h\u2082 : b \u2192 a) : a \u2194 b :=\nbegin\n  from iff.intro h\u2081 h\u2082,\nend\n\n/-\n\nWe can use the previously encountered \u2018split\u2019 tactic to solve iff introduction \nstatements backwards. Again, this isn\u2019t necessary but can often turn a more complex \nproof into two simpler ones.\n\n-/\n\nnamespace exlean -- hide\n\n/- Theorem : no-side-bar\nLet $a$, $b$, $c$, $x$, $y$, and $z$ be propositions, and assume $h_1 : (b \\land c) \\iff a$, \n$h_2 : (y \\land z) \\iff x$, and $h_3 : a \\iff x$. Then $(b \\land c) \\iff (y \\land z)$.\n-/\n\ntheorem iff_intro (a b c x y z: Prop) (h\u2081 : (b \u2227 c) \u2194 a) (h\u2082 : (y \u2227 z) \u2194 x) \n(h\u2083 : a \u2194 x) : (b \u2227 c) \u2194 (y \u2227 z) :=\nbegin\n", "proof": "  cases h\u2081 with g\u2081 g\u2082,\n  cases h\u2082 with f\u2081 f\u2082,\n  cases h\u2083 with e\u2081 e\u2082,\n  split,\n  {assume g : b \u2227 c, show y \u2227 z,\n  have r\u2081 : a, from g\u2081 g,\n  have r\u2082 : x, from e\u2081 r\u2081,\n  from f\u2082 r\u2082,},\n  {assume f : y \u2227 z, show b \u2227 c,\n  have t\u2081 : x, from f\u2081 f,\n  have t\u2082 : a, from e\u2082 t\u2081,\n  from g\u2082 t\u2082,},\n  \n  \n  \n  ", "proof_hint": "sorry", "textAfter": "\nend\n\n\nend exlean -- hide\n", "height": 16, "editorText": "sorry", "lineOffset": 38, "name": "iff_intro", "statement": "(a b c x y z: Prop) (h\u2081 : (b \u2227 c) \u2194 a) (h\u2082 : (y \u2227 z) \u2194 x) \n(h\u2083 : a \u2194 x) : (b \u2227 c) \u2194 (y \u2227 z)"}, {"type": "lean", "content": "91", "hidden": true}]}]}, {"name": "92", "levels": [{"name": "", "problemIndex": 3, "objects": [{"type": "lean", "content": "93", "hidden": true}, {"type": "text", "content": "94"}, {"type": "lean", "content": "95", "hidden": true}, {"type": "theorem", "text": "96", "lean": "theorem distributivty_of_and_over_or (a b c : Prop) (h : a \u2227 (b \u2228 c)) : (a \u2227 b) \u2228 (a \u2227 c) :=\n", "sideBar": false, "firstProofLineNumber": 16, "lastProofLineNumber": 26, "textBefore": "import propositional_logic.imp_elim -- hide\n\n/-\n# Bonus\n## Level 1: Distriubtivity of and over or\n\n-/\n\nnamespace exlean -- hide\n\n/- Theorem : no-side-bar\nLet $a$, $b$, and $c$ be propositions. Assuming $h : a \\land (b \\lor c))$, we have $(a \\land b) \\lor (a \\land c)$.\n-/\ntheorem distributivty_of_and_over_or (a b c : Prop) (h : a \u2227 (b \u2228 c)) : (a \u2227 b) \u2228 (a \u2227 c) :=\nbegin\n", "proof": "  have h\u2081 : a, from and.elim_left h,\n  have h\u2082 : b \u2228 c, from and.elim_right h,\n  from or.elim h\u2082\n    (assume g\u2081 : b,\n    have g\u2082 : a \u2227 b, from and.intro h\u2081 g\u2081,\n    show (a \u2227 b) \u2228 (a \u2227 c), from or.inl g\u2082)\n    (assume f\u2081 : c,\n    have f\u2082 : a \u2227 c, from and.intro h\u2081 f\u2081,\n    show (a \u2227 b) \u2228 (a \u2227 c), from or.inr f\u2082),\n    \n    ", "proof_hint": "sorry", "textAfter": "\nend\n\nend exlean -- hide\n", "height": 11, "editorText": "sorry", "lineOffset": 15, "name": "distributivty_of_and_over_or", "statement": "(a b c : Prop) (h : a \u2227 (b \u2228 c)) : (a \u2227 b) \u2228 (a \u2227 c)"}, {"type": "lean", "content": "97", "hidden": true}]}, {"name": "", "problemIndex": 3, "objects": [{"type": "lean", "content": "98", "hidden": true}, {"type": "text", "content": "99"}, {"type": "lean", "content": "100", "hidden": true}, {"type": "theorem", "text": "101", "lean": "theorem distributivity_of_or_over_2and {a b c : Prop} (h : (a \u2227 b) \u2228 (a \u2227 c)) : a \u2227 (b \u2228 c) :=\n", "sideBar": false, "firstProofLineNumber": 16, "lastProofLineNumber": 30, "textBefore": "import propositional_logic.imp_elim -- hide\n\n/-\n# Bonus\n## Level 2: Distriubtivity of or over and\n\n-/\n\nnamespace exlean -- hide\n\n/- Theorem : no-side-bar\nLet $a$, $b$, and $c$ be propositions and assume $h : (a \\land b) \\lor (a \\land c)$. Then $a \\land (b \\lor c)$.\n-/\ntheorem distributivity_of_or_over_2and {a b c : Prop} (h : (a \u2227 b) \u2228 (a \u2227 c)) : a \u2227 (b \u2228 c) :=\nbegin\n", "proof": "  from or.elim h\n    (assume g : a \u2227 b,\n    have g\u2081 : a, from g.left,\n    have g\u2082 : b, from g.right,\n    have g\u2083 : b \u2228 c, from or.inl g\u2082,\n    show a \u2227 (b \u2228 c), from and.intro g\u2081 g\u2083)\n    (assume f : a \u2227 c,\n    have f\u2081 : a, from f.left,\n    have f\u2082 : c, from f.right,\n    have f\u2083 : b \u2228 c, from or.inr f\u2082,\n    show a \u2227 (b \u2228 c), from and.intro f\u2081 f\u2083),\n    \n    \n    \n    ", "proof_hint": "sorry", "textAfter": "\nend\n\nend exlean -- hide\n", "height": 15, "editorText": "sorry", "lineOffset": 15, "name": "distributivity_of_or_over_2and", "statement": "{a b c : Prop} (h : (a \u2227 b) \u2228 (a \u2227 c)) : a \u2227 (b \u2228 c)"}, {"type": "lean", "content": "102", "hidden": true}]}, {"name": "", "problemIndex": 3, "objects": [{"type": "lean", "content": "103", "hidden": true}, {"type": "text", "content": "104"}, {"type": "lean", "content": "105", "hidden": true}, {"type": "theorem", "text": "106", "lean": "theorem iff_disj_example (a b c : Prop) (h\u2081 : (a \u2228 b) \u2228 c) (h\u2082 : b \u2194 c) : c \u2228 a :=\n", "sideBar": false, "firstProofLineNumber": 16, "lastProofLineNumber": 29, "textBefore": "import propositional_logic.imp_elim -- hide\n\n/-\n# Bonus\n## Level 3: Iff and disjunction problem\n-/\n\nnamespace exlean -- hide\n\n/- Theorem : no-side-bar\nLet $a$, $b$, and $c$ be propositions, and assume $h_1 : (a \\lor b) \\lor c$, and $h_2 : b \\iff c$. \nThen $c \\lor a$.\n-/\ntheorem iff_disj_example (a b c : Prop) (h\u2081 : (a \u2228 b) \u2228 c) (h\u2082 : b \u2194 c) : c \u2228 a :=\nbegin\n", "proof": "have h\u2083 : b \u2192 c, from iff.elim_left h\u2082,\nhave h\u2084 : c \u2192 b, from iff.elim_right h\u2082,\nfrom or.elim h\u2081\n    (assume g\u2081 : a \u2228 b,\n    or.elim g\u2081\n        (assume f\u2081 : a,\n        show c \u2228 a, from or.inr f\u2081)\n        (assume f\u2082 : b,\n        have f\u2083 : c, from h\u2083 f\u2082,\n        show c \u2228 a, from or.inl f\u2083))\n    (assume g\u2082 : c,\n    show c \u2228 a, from or.inl g\u2082),\n    \n    ", "proof_hint": "sorry", "textAfter": "\nend\n\nend exlean -- hide\n", "height": 14, "editorText": "sorry", "lineOffset": 15, "name": "iff_disj_example", "statement": "(a b c : Prop) (h\u2081 : (a \u2228 b) \u2228 c) (h\u2082 : b \u2194 c) : c \u2228 a"}, {"type": "lean", "content": "107", "hidden": true}]}, {"name": "", "problemIndex": 3, "objects": [{"type": "lean", "content": "108", "hidden": true}, {"type": "text", "content": "109"}, {"type": "lean", "content": "110", "hidden": true}, {"type": "theorem", "text": "111", "lean": "theorem double_iff_ex (a b c d : Prop)(h\u2081 : a \u2194 c) (h\u2082 : b \u2194 d) : (a \u2228 b) \u2194 (c \u2228 d) :=\n", "sideBar": false, "firstProofLineNumber": 16, "lastProofLineNumber": 39, "textBefore": "import propositional_logic.imp_elim -- hide\n\n/-\n# Bonus\n## Level 4: Double iff problem\n-/\n\nnamespace exlean -- hide\n\n/- Theorem : no-side-bar\nLet $a$, $b$, $c$, and $d$ be propositions, and assume $h_1 : a \\iff c$, and $h_2 : b \\iff d$. \nThen $(a \\lor b) \\iff (c \\lor d)$.\n-/\ntheorem double_iff_ex (a b c d : Prop)(h\u2081 : a \u2194 c) (h\u2082 : b \u2194 d) : (a \u2228 b) \u2194 (c \u2228 d) :=\nbegin\n", "proof": "  have h\u2083 : a \u2192 c, from iff.elim_left h\u2081,\n  have h\u2084 : c \u2192 a, from iff.elim_right h\u2081,\n  have h\u2085 : b \u2192 d, from iff.elim_left h\u2082,\n  have h\u2086 : d \u2192 b, from iff.elim_right h\u2082,\n  from iff.intro\n    (assume h : a \u2228 b,\n    or.elim h\n        (assume f\u2081 : a,\n        have f\u2082 : c, from h\u2083 f\u2081,\n        or.inl f\u2082)\n        (assume f\u2083 : b,\n        have f\u2084 : d, from h\u2085 f\u2083,\n        or.inr f\u2084))\n    (assume g : c \u2228 d,\n    or.elim g\n        (assume g\u2081 : c,\n        have g\u2082 : a, from h\u2084 g\u2081,\n        or.inl g\u2082)\n        (assume g\u2083 : d,\n        have g\u2084 : b, from h\u2086 g\u2083,\n        or.inr g\u2084)),\n        \n        \n        ", "proof_hint": "sorry", "textAfter": "\nend\n\nend exlean -- hide\n", "height": 24, "editorText": "sorry", "lineOffset": 15, "name": "double_iff_ex", "statement": "(a b c d : Prop)(h\u2081 : a \u2194 c) (h\u2082 : b \u2194 d) : (a \u2228 b) \u2194 (c \u2228 d)"}, {"type": "lean", "content": "112", "hidden": true}]}], "parents": [0]}], "texts": [["Lean Game Template", "# Propositional Logic Game, version 0.1\n\n## By Lucy Chapman\n\nThis is an interactive resource created with the intention of teaching the basics \nof propositional logic through the use of the theorem prover LEAN. \n\nUsing this game is very straight forward- simply enter into the first world by clicking\non the top circle on the right-hand side of your screen and work your way through the \nvarious levels within. In each level you can expect to find examples as well as a problem \nfor you to solve. You\u2019ll know you\u2019ve successfully solved the problem when the box on the \nright-hand side reads \u2018Proof complete!\u2019.\n\nOnce you\u2019re done with the first world you should then be ready to tackle the second world,\nwhich does away with examples and explanations, instead consisting of four levels where all \nthere is to do is complete a proof.\n\nIf you complete all the levels of this game but still feel hungry to complete more proofs, \ncheck out the games linked in the credits.\n\n\n## Credits\n\nThis game was made using the\n<a href=\"https://github.com/mpedramfar/Lean-game-maker\">Lean Game Maker</a> by Mohammad Pedramfar.\n\nIt uses ideas and special tactics from the \n<a href=\"https://www.ma.imperial.ac.uk/~buzzard/xena/natural_number_game/\">Natural Number Game</a>\nby Kevin Buzzard.\n\n<a href=\"https://leanprover.github.io/\" target=\"blank\">Lean</a> is an interactive theorem prover developed at Microsoft Research under the direction of\nLeonardo de Moura.\n\nMathlib, Lean's mathematical library, is developed by the <a href=\"https://leanprover-community.github.io/\" target=\"blank\">Lean community</a>.\n", "First World", "import data.int.basic tactic.pure_maths -- hide\n", "# Propositional logic\n## Level 1: And elimination\n\nWelcome to propositional logic in LEAN! In this first level, we will introduce the \nconcept of and elimination.\n\nSay we have the hypothesis \u2018h: cats AND dogs\u2019, we can logically conclude that we have \n\u2018cats\u2019, and that we have \u2018dogs\u2019. But how do we actually prove these two facts? By \nusing and elimination!\n", "example (dogs cats : Prop) (h: dogs \u2227 cats) : cats :=\nbegin\n  from h.right,\nend\nexample (dogs cats : Prop) (h: dogs \u2227 cats) : dogs :=\nbegin\n  from h.left,\nend\n", "\nThese are the proofs in LEAN, but what do they actually mean? h is our hypothesis \n(or premise), which is a fancy way of saying that h is what we know. The symbol \u2227 is\ncalled a conjugation (it just means \u2018and\u2019) and can be typed in LEAN using \\and. \n\nIn the first example, \u2018cats\u2019 is our goal, and we reach this goal by using \u2018from h.right\u2019,\nwhich is an abbreviation for \u2018from and_elim_right h\u2019. Informally, this is the same as \nsaying \u2018we have cats from right and elimination on h\u2019.\n\nAnd the second example is the same, but we instead use \u2018from h.left\u2019 (short for \n\u2018from and.elim_left h\u2019) to reach our goal of \u2018dogs\u2019. Informally, this is \u2018we have dogs \nfrom left and elimination on h\u2019.\n\nThis example was rather a simple one, now let\u2019s look at one with more than one conjugation.\n", "example (red blue yellow : Prop) (h: red \u2227 (blue \u2227 yellow)) : yellow :=\nbegin\n  have g: blue \u2227 yellow, from h.right,\n  from g.right,\nend\n", "\nIn this example, our hypothesis is \u2018h: red and (blue and yellow)\u2019 and our goal is to \nshow that we have yellow. The first step to achieving this is \u2018have g: blue \u2227 yellow, from \nh.right\u2019. This creates a new hypothesis g, and is equivalent to saying \u2018we have \u201cg: blue and \nyellow\u201d from right and elimination on h\u2019. We complete the proof in exactly the same way as \nin the first example, except this time we use \u2018from g.right\u2019, or informally, \u2018we have yellow\nfrom right and elimination on g\u2019.\n\nAnother way we can create a new hypothesis from our original one is to use the tactic \n\u2018cases\u2019. This tactic will automatically decompose a hypothesis with a conjugation into \nit\u2019s left and right hand sides. Here\u2019s the last example, but this time using the \ntactic \u2018cases\u2019.\n\n", "example (red blue yellow : Prop) (h: red \u2227 (blue \u2227 yellow)) : yellow :=\nbegin\n  cases h with f g,\n  from g.right,\nend\n", "\nAs you can see, we instead started our proof with \u2018cases h with f g\u2019, which creates the two \nnew premises, \u2018f: red\u2019 and \u2018g: blue \u2227 yellow\u2019, and the rest of the proof follows as before.\n\n", "`cases` is a general-purpose elimination tactic. It it used to 'decompose' a hypothesis into\nits constituent parts.\n\n### Examples\n\n* Given `h : \u2203 (x : \u2124), x + 5 = y`, typing `cases h with m h\u2082` replaces `h` with `m : \u2124` and\n`h\u2082 : m + 5 = y`.\n\n* Given `h : p \u2227 q`, typing `cases h with hp hq` replaces `h` with `hp : p` and `hq : q`.\n\n* Given `h : p \u2228 q`, typing `cases h with hp hq` replaces the current goal with two goals\n(1) in which `h` is replaced with `hp : p` and (2) in which `h` is replaced with `hq : q`.\n\n* Given `x : \u2115`, typing `cases x with k` replaces the goal with two new goals: (1) a goal in which\nevery occurence of `x` is replaced with `0` and (2) a goal with a new variable `k : \u2115` and in \nwhich every occurrence of `x` is replaced with `succ k`.\n\n* Given `h : \u2203 (x : X), P(x)`, typing `cases h with y h\u2082` introduces a new variable `y : X`\nand replaces `h` with `h\u2082 : P(y)`.\n", "namespace exlean -- hide\n", "\nNow it\u2019s your turn to have a go! Below, you will find a problem that can be solved using a \ncombination of left and elimination and right and elimination (and the tactic \u2018cases\u2019 if you \nso desire\u2019). Remember to end each line with a comma, and you\u2019ll know your proof is correct if \nthe right hand side box says \u2018Proof complete!\u2019.\n\n", "Let $a$, $b$, $c$ be propositions. Assuming $h: a \\land ((b \\land a) \\land c)$, we have $b$.\n", "end exlean -- hide\n", "import tactic.pure_maths -- hide\n", "# Propositional logic\n## Level 2: And introduction\n\nNow that you\u2019ve seen how to prove a proposition from a conjugation, it\u2019s time to prove a \nconjugation from a proposition! \n\nLet\u2019s take our initial example of dogs and cats from level 1 but instead go the other way.\n\n", "example (dogs cats : Prop) (h: dogs) (g: cats) : dogs \u2227 cats :=\nbegin \n  from and.intro h g,\nend\n", "\nThis time, we started with two hypotheses, \u2018h: dogs\u2019 and \u2018g: cats\u2019, and our goal was to \nprove \u2018dogs and cats\u2019. We did this using and introduction, which is the propositional logic \nway of saying \u2018if we have dogs, and we have cats, then we have dogs and cats\u2019.\n\nAnother way in which we can prove a conjugation is to break it down into two separate \ngoals. This is done by using the \u2018split\u2019 tactic.\n\n", "example (dogs cats : Prop) (h: dogs) (g: cats) : dogs \u2227 cats :=\nbegin \n  split,\n  {show dogs, from h, },\n  {show cats, from g, },\nend\n", "\nAs you can see, the \u2018split\u2019 tactic changed our single goal of \u2018dogs and cats\u2019 into \ntwo separate goals, one being \u2018dogs\u2019 and the other being \u2018cats\u2019. This is an example\nof a backwards proof, and is in some cases easier than trying to construct a proof \nin the forwards direction. \n\nYou may have noticed that after using the split tactic, we introduced some curly \nbrackets. This is because we now have two goals, so the brackets tell LEAN which \nlines of our proof relate to each goal.\n\n", "namespace exlean -- hide\n", "\nHave a go at constructing the following proof. You may use either \u2018and.intro\u2019 or the \nsplit tactic to do so.\n\n", "Let $a$, $b$, $c$ be propositions. Assuming $h: a$, $g: b$, and $f: c$, we have $c \\land a$.\n", "end exlean -- hide\n", "import tactic.pure_maths -- hide\n", "# Propositional logic\n## Level 3: And swap\n\nIn this level, we will be proving that you can get $b \\land a$ from $a \\land b$. \nIntuitively, I\u2019m sure this fact is obvious but before we can just use it in future \nproofs, we need to prove it's true. After this level, you'll be able to use 'and.swap' \nto swap the propositions in a conjugation. Levels 1 and 2 have given us all the tools \nwe need to do this, so I leave the rest up to you!\n\n", "namespace exlean -- hide\n", "Let $a$ and $b$ be propositions. Assuming $h: a \\land b$, we have $g: b \\land a$.\n", "end exlean -- hide\n", "import propositional_logic.and_swap -- hide\n", "# Propositional logic\n## Level 4: Implication elimination\n\nNow we will start to consider implications, starting with implication elimination. \nIf we are given the hypotheses $h: a \\r b$ and $g : a$ then we have a proof of a.\n\n", "example (a b : Prop) (h : a \u2192 b) (g : a) : b :=\nbegin\n  from h g,\nend \n", "\nAs you can see, this example isn\u2019t exactly complicated but we can combine our \nimplication elimination with what we\u2019ve seen in previous levels to construct more \ncomplex proofs. Have a go at the one below, using the theorems and tactics we\u2019ve \ncovered so far.\n\n(Note that the implication arrow can be written in LEAN using \u2018\\r\u2019)\n\n", "namespace exlean -- hide\n", "Let $a$, $b$, $c$, and $d$ be propositions. Assuming $h : a \\to b$, $g : c \\land d$,\nand $f : d \\to a$, we have $b$.\n", "end exlean -- hide\n", "import propositional_logic.imp_elim -- hide\n", "# Propositional logic\n## Level 5: Implication introduction\n\nContinuing on our implication journey, in this level we will be looking at implication \nintroduction. It\u2019s worth prefacing this level by saying that the first couple of examples \nmay seem so obvious as to be trivial, so take a moment to consider why they are important\nstatements to prove.\n\n", "variable (a : Prop)\nexample : a \u2192 a  :=\nbegin\n  assume h : a,\n  show a, from h,\nend\n", "\nThis lemma is very simple but is important to have in our arsenal. In order to prove it, \nwe assumed a hypothesis to be true, that being $h : a$, and then proved that having $a$ \nimplies that we have $a$. Much like with implication elimination, we can combine it with\nour previous theorems to construct longer proofs.\n\n", "example (a b : Prop) : (a \u2227 b) \u2192 b :=\nbegin\n  assume h : a \u2227 b,\n  from and.elim_right h,\nend\n", "namespace exlean -- hide\n", "\nHave a go at the example below and in the next level we\u2019ll meet a slightly more involved \nproof.\n\n", "Let $a$, $b$, and $c$ be propositions and assume $h : b \\to c$. Then $(a \\land b) \\to c$.\n", "end exlean -- hide\n", "import propositional_logic.imp_elim -- hide\n", "#Propositional logic\n## Level 6: Conjugation and Implication\n\nin this level there will be no examples, instead there is just a single, \nlonger exercise for you to have a go at before we move on to the next level.\n\n", "namespace exlean -- hide\n", "Let $a$, $b$, $c$, and $d$ be propositions. Assuming $h_1 : a \\to b$, $h_2 : a \\land c$,\nand $h_3 : (c \\land a) \\to d$, we have $d \\land b$.\n", "end exlean -- hide\n", "import propositional_logic.imp_elim -- hide\n", "#Propositional logic\n## Level 7: Or introduction\n\nNow it is time to introduce disjunction, which is represented by the symbol \n$ \\lor $, which can be typed in LEAN as \u2018\\or\u2019. Let\u2019s look to an example to \nsee how it works.\n\n", "example (a b : Prop) (h : a) : a \u2228 b :=\nbegin\n  from or.inl h,\nend\n", "\nIn the above example, our hypothesis is $h : a$ and our goal is to show $a \\lor b$. \nThis is done using or introduction on $h$. Informally, we can look at this as \u2018if we \nhave $a$, then we have $a$ or $b$\u2019.\n\nIt\u2019s important to note that in a true disjunction statement such as \u2018$p \\lor q$\u2019 it \nis possible that both $p$ and $q$ are true but it is sufficient for only one of them \nto be true.\n\nOr introduction isn\u2019t often used in isolation, but rather it is paired with other \nrules of inference, and so the following exercise will use or introduction as well as \ntheorems from previous levels.\n\n", "namespace exlean -- hide\n", "Let $a$, $b$, $c$, and $d$ be propositions, and assume $h_1 : a$, $h_2 : b$, and $h_3. \nThen we have $d \\lor (a \\land (b \\land c)).\n", "end exlean -- hide\n", "import propositional_logic.and_swap -- hide\n", "# Propositional logic\n## Level 8: Or elimination\n\nNow we will introduce or elimination. Informally, this works by showing that\nboth sides of a disjunction lead to our goal.\n\n", "example (a b c : Prop) (h\u2081 : a \u2228 b) (h\u2082 : a \u2192 c) (h\u2083 : b \u2192 c) : c :=\nbegin\n  from or.elim h\u2081 h\u2082 h\u2083,\nend\n", "\nAlthough the above proof is only a single line, we\u2019re actually doing a fair bit. \nOr elimination breaks up the disjunction into two separate assumptions; in this \ncase the assumption of $a$ and then the assumption of $b$. We then prove that each\nof these individual assumptions implies our goal and, as we know at least one of \nthe assumptions is true, we can conclude that we have reached our goal.\n\nOr introduction is often used alongside negation, which we\u2019ll get to in the next \nlevel, but for now have a go at the exercise below.\n\n", "namespace exlean -- hide\n", "Let $a$, $b$, $c$, and $d$ be propositons. Assuming $h_1 : a \\lor b$, $h_2 : a \\to c$,\n$h_3 : a \\to b$, $h_4 : d \\to b$, and $h_5 : d \\to c$, we have $b \\land c$.\n", "end exlean -- hide\n", "import propositional_logic.imp_elim -- hide\n", "#Propositional logic\n## Level 9: Negation\n\nNegation is the propositional logic way of saying \u2018not\u2019. The symbol for negation is $\\neg$ \nand is written in LEAN using \u2018\\neg\u2019. As you would expect, two negations informally\nmeans \u2018not-not\u2019, and so we can prove that \u2018$p \\to \\neg \\neg p$\u2019.\n\n", "example (p : Prop) : p \u2192 \u00ac\u00acp :=\nbegin\n  assume h : p,\n  show \u00ac \u00ac p,\n  show \u00acp \u2192 false,\n  assume g : \u00ac p,\n  show false, from g h,\nend\n", "\nThe above proof starts how we expect an implication proof to start, by assuming $h : p$. \nOur initial goal is to show \u2018$ \\neg \\neg p$\u2019 and in order to achieve this we change our \ngoal to showing \u2018$ \\neg p \\to \\bot$\u2019 (note that $\\bot$ is written as \u2018false\u2019 in LEAN). This \nis another implication proof, so we again start with an assumption \u2018$g : \\neg p$\u2019, making \nour goal simply \u2018$\\bot$\u2019. This follows from $h$ and $g$ as we can\u2019t have both $p$ and $\\neg p$\nwithout having a contradiction.\n\nNegation can be hard to wrap your head around when written down in such a way, so it\u2019s worth \ntaking some time to really understand what\u2019s going on in the example above. It\u2019s an example \nof proof by contradiction, as is the exercise below.\n\n", "namespace exlean -- hide\n", "Let $a$, and $b$ be propositions. Then $(a \\to b) \\to (\\neg b \\to \\neg a)$.\n", "end exlean -- hide\n", "import propositional_logic.imp_elim -- hide\n", "#Propositional logic\n## Level 10: Disjunction and Negation\n\nAs mentioned in level 8, disjunction is often found alongside negation. There \nare no examples in this level, instead there is a lemma for you to prove, using \nwhat you\u2019ve learnt in the previous levels.\n\n", "namespace exlean -- hide\n", "Let $a$, and $b$ be propositions. Then $(\\neg a \\lor \\neg b) \\to \\neg (a \\land b)$.\n", "end exlean -- hide\n", "import propositional_logic.imp_elim -- hide\n", "#Propositional logic\n## Level 11: Iff elimination\n\n\u2018Iff\u2019 (shorthand for \u2018if and only if\u2019, written in LEAN as \u2018\\iff\u2019) is an implication \nthat goes both ways.\n\n", "example (a b : Prop) (h : a \u2194 b) : a \u2192 b :=\nbegin\n  from iff.elim_left h,\nend\nexample (a b : Prop) (h : a \u2194 b) : b \u2192 a :=\nbegin\n  from iff.elim_right h,\nend\n", "\nBy using left iff elimination, we are able to prove from $a \\iff b$ that $a \\to b$, \nand similiarly using right iff elimination, we can prove $b \\to a$. There\u2019s not much\nmore to iff elimination, so have a go at the exercise and then move on to the finally \nlevel in this world.\n\n", "namespace exlean -- hide\n", "Let $a$, $b$, and $c$ be propositions. Assuming $h : a \\iff (b \\land c)$, then $a \\to c$.\n", "end exlean -- hide\n", "import propositional_logic.imp_elim -- hide\n", "#Propositional logic\n## Level 12: Iff introduction\n\nWelcome to the final level of propositional logic! Once you\u2019ve completed this \nlevel, there\u2019s a bonus world with some more challenging proofs to have a go at so \nplease head back to the main menu and have a go. But first, iff introduction!\n\nIff introduction, as you might expect, if the opposite of iff elimination; it takes\ntwo implication statements and creates a single iff statement.\n\n", "example (a b : Prop) (h\u2081 : a \u2192 b) (h\u2082 : b \u2192 a) : a \u2194 b :=\nbegin\n  from iff.intro h\u2081 h\u2082,\nend\n", "\nWe can use the previously encountered \u2018split\u2019 tactic to solve iff introduction \nstatements backwards. Again, this isn\u2019t necessary but can often turn a more complex \nproof into two simpler ones.\n\n", "namespace exlean -- hide\n", "Let $a$, $b$, $c$, $x$, $y$, and $z$ be propositions, and assume $h_1 : (b \\land c) \\iff a$, \n$h_2 : (y \\land z) \\iff x$, and $h_3 : a \\iff x$. Then $(b \\land c) \\iff (y \\land z)$.\n", "end exlean -- hide\n", "Second World", "import propositional_logic.imp_elim -- hide\n", "# Bonus\n## Level 1: Distriubtivity of and over or\n\n", "namespace exlean -- hide\n", "Let $a$, $b$, and $c$ be propositions. Assuming $h : a \\land (b \\lor c))$, we have $(a \\land b) \\lor (a \\land c)$.\n", "end exlean -- hide\n", "import propositional_logic.imp_elim -- hide\n", "# Bonus\n## Level 2: Distriubtivity of or over and\n\n", "namespace exlean -- hide\n", "Let $a$, $b$, and $c$ be propositions and assume $h : (a \\land b) \\lor (a \\land c)$. Then $a \\land (b \\lor c)$.\n", "end exlean -- hide\n", "import propositional_logic.imp_elim -- hide\n", "# Bonus\n## Level 3: Iff and disjunction problem\n", "namespace exlean -- hide\n", "Let $a$, $b$, and $c$ be propositions, and assume $h_1 : (a \\lor b) \\lor c$, and $h_2 : b \\iff c$. \nThen $c \\lor a$.\n", "end exlean -- hide\n", "import propositional_logic.imp_elim -- hide\n", "# Bonus\n## Level 4: Double iff problem\n", "namespace exlean -- hide\n", "Let $a$, $b$, $c$, and $d$ be propositions, and assume $h_1 : a \\iff c$, and $h_2 : b \\iff d$. \nThen $(a \\lor b) \\iff (c \\lor d)$.\n", "end exlean -- hide\n"]]}